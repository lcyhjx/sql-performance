# usp_UpdateProjectRiskRelationInfo 优化使用说明

## 快速开始

本文档提供了存储过程优化的快速实施指南。

---

## 文件说明

| 文件名 | 说明 |
|--------|------|
| `usp_UpdateProjectRiskRelationInfo_definition.sql` | 原始存储过程定义 |
| `usp_UpdateProjectRiskRelationInfo_Optimized.sql` | 优化后的存储过程 |
| `Create_Indexes.sql` | 索引创建脚本 |
| `Performance_Test.sql` | 性能对比测试脚本 |
| `性能问题分析.md` | 详细的性能问题分析 |
| `性能优化报告.md` | 完整的优化报告 |

---

## 实施步骤

### 步骤1: 创建优化索引 (可选但强烈建议)

**执行文件**: `Create_Indexes.sql`

**执行时间**: 业务低峰期(建议凌晨2-4点)

**预计耗时**: 30-60分钟

**操作步骤**:

```sql
-- 在 SQL Server Management Studio 中执行
USE [Statistics-CT-test];
GO

-- 打开并执行 Create_Indexes.sql
```

**注意事项**:
- 索引创建使用了 `ONLINE = ON` 选项,不会完全锁表
- 会占用约2-3GB磁盘空间
- 建议在执行前检查磁盘空间
- 创建过程中可以正常使用数据库

---

### 步骤2: 创建优化后的存储过程

**执行文件**: `usp_UpdateProjectRiskRelationInfo_Optimized.sql`

**预计耗时**: < 1分钟

**操作步骤**:

```sql
-- 在 SQL Server Management Studio 中执行
USE [Statistics-CT-test];
GO

-- 打开并执行 usp_UpdateProjectRiskRelationInfo_Optimized.sql
-- 这会创建名为 usp_UpdateProjectRiskRelationInfo_Optimized 的存储过程
```

---

### 步骤3: 运行性能测试(可选)

**执行文件**: `Performance_Test.sql`

**预计耗时**: 2-5分钟

**操作步骤**:

```sql
-- 在 SQL Server Management Studio 中执行
USE [Statistics-CT-test];
GO

-- 打开并执行 Performance_Test.sql
-- 会自动对比原始版本和优化版本的性能
```

**测试说明**:
- 测试会执行原始版本3次
- 然后执行优化版本3次
- 最后输出性能对比报告

**示例输出**:
```
原始版本平均执行时间:   6,463.00 ms
优化版本平均执行时间:   1,850.00 ms
性能提升:              71.38%
加速倍数:              3.49x

✓ 优化成功! 性能提升了 71.38%
  [优秀] 性能提升超过50%
```

---

### 步骤4: 验证数据一致性

**目的**: 确保优化后的存储过程产生相同的结果

**操作步骤**:

```sql
-- 1. 记录当前状态
SELECT
    ProjectID,
    ContractSignStatus,
    ProductionOpenningDate,
    ProductionEndDate,
    CurrentProjSalesTotalAmt,
    CurrentProjReturnTotalAmt
INTO #Before
FROM ProjectRiskRelationInfo
ORDER BY ProjectID;

-- 2. 执行优化版本
EXEC dbo.usp_UpdateProjectRiskRelationInfo_Optimized;

-- 3. 记录新状态
SELECT
    ProjectID,
    ContractSignStatus,
    ProductionOpenningDate,
    ProductionEndDate,
    CurrentProjSalesTotalAmt,
    CurrentProjReturnTotalAmt
INTO #After
FROM ProjectRiskRelationInfo
ORDER BY ProjectID;

-- 4. 对比差异(应该没有差异)
SELECT
    'Before' AS Source,
    COUNT(*) AS RowCount,
    SUM(CurrentProjSalesTotalAmt) AS TotalSalesAmt,
    SUM(CurrentProjReturnTotalAmt) AS TotalReturnAmt
FROM #Before
UNION ALL
SELECT
    'After' AS Source,
    COUNT(*) AS RowCount,
    SUM(CurrentProjSalesTotalAmt) AS TotalSalesAmt,
    SUM(CurrentProjReturnTotalAmt) AS TotalReturnAmt
FROM #After;

-- 清理
DROP TABLE #Before, #After;
```

---

### 步骤5: 替换生产存储过程(谨慎操作!)

⚠️ **重要提示**: 此步骤会替换生产环境的存储过程,请谨慎操作!

**前置条件**:
- ✅ 索引已创建
- ✅ 性能测试通过
- ✅ 数据一致性验证通过
- ✅ 数据库已备份

**操作步骤**:

```sql
-- 在业务低峰期执行

USE [Statistics-CT-test];
GO

-- 1. 备份原始存储过程(已在步骤1完成)

-- 2. 删除原始存储过程
DROP PROCEDURE IF EXISTS dbo.usp_UpdateProjectRiskRelationInfo;
GO

-- 3. 重命名优化版本
EXEC sp_rename
    'dbo.usp_UpdateProjectRiskRelationInfo_Optimized',
    'usp_UpdateProjectRiskRelationInfo';
GO

-- 4. 验证
EXEC dbo.usp_UpdateProjectRiskRelationInfo;

PRINT '存储过程已成功替换!';
```

---

## 回滚方案

如果优化后出现问题,可以快速回滚:

```sql
USE [Statistics-CT-test];
GO

-- 1. 删除当前版本
DROP PROCEDURE IF EXISTS dbo.usp_UpdateProjectRiskRelationInfo;
GO

-- 2. 从备份文件恢复原始版本
-- 执行 usp_UpdateProjectRiskRelationInfo_definition.sql

PRINT '已回滚到原始版本';
```

---

## 主要优化点总结

### 1. 性能优化
- ✅ 为所有临时表添加索引
- ✅ 使用变量缓存子查询结果
- ✅ 合并重复的 AccountReceivable 查询
- ✅ 优化日期计算
- ✅ 使用 MERGE 替代 UPDATE + INSERT

### 2. 稳定性优化
- ✅ 添加完整的事务控制
- ✅ 实现错误处理和回滚机制
- ✅ 移除 UPDATE 中的 NOLOCK (数据安全)

### 3. 可维护性优化
- ✅ 添加执行日志和性能监控
- ✅ 分步骤输出执行进度
- ✅ 清晰的代码结构和注释

---

## 预期性能提升

| 指标 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 执行时间 | 6.5秒 | 1.5-2.5秒 | 60-75% ↓ |
| IO读取 | ~400K页 | ~150K页 | 62% ↓ |
| CPU时间 | ~12秒 | ~3-5秒 | 60-75% ↓ |

---

## 监控和维护

### 性能监控查询

```sql
-- 查看存储过程执行统计
SELECT
    OBJECT_NAME(object_id) AS ProcedureName,
    execution_count AS 执行次数,
    total_elapsed_time / 1000 / execution_count AS 平均耗时_毫秒,
    total_worker_time / 1000 / execution_count AS 平均CPU时间_毫秒,
    total_logical_reads / execution_count AS 平均逻辑读取_页,
    last_execution_time AS 最后执行时间
FROM sys.dm_exec_procedure_stats
WHERE object_name(object_id) = 'usp_UpdateProjectRiskRelationInfo';
```

### 索引使用情况监控

```sql
-- 查看新创建的索引使用情况
SELECT
    OBJECT_NAME(s.object_id) AS 表名,
    i.name AS 索引名,
    s.user_seeks AS 查找次数,
    s.user_scans AS 扫描次数,
    s.user_lookups AS 查询次数,
    s.user_updates AS 更新次数,
    s.last_user_seek AS 最后查找时间
FROM sys.dm_db_index_usage_stats s
INNER JOIN sys.indexes i
    ON s.object_id = i.object_id AND s.index_id = i.index_id
WHERE s.database_id = DB_ID()
    AND i.name LIKE '%_Optimized'
ORDER BY s.user_seeks + s.user_scans + s.user_lookups DESC;
```

---

## 常见问题

### Q1: 索引创建会锁表吗?
**A**: 使用了 `ONLINE = ON` 选项,创建过程中表仍可正常访问,只在完成时需要短暂的排它锁。

### Q2: 如果索引创建失败怎么办?
**A**: 索引创建失败不会影响现有功能,可以在低峰期重试。确保有足够的磁盘空间。

### Q3: 优化后存储过程的结果会不同吗?
**A**: 不会。优化只改变执行方式,不改变业务逻辑,结果应该完全相同。

### Q4: 可以只应用部分优化吗?
**A**: 可以。但建议全部应用以获得最佳效果。最低限度应该:
- 移除 UPDATE 中的 NOLOCK
- 添加事务控制

### Q5: 性能提升达不到预期怎么办?
**A**:
1. 检查索引是否正确创建
2. 更新统计信息: `UPDATE STATISTICS [表名] WITH FULLSCAN`
3. 检查是否有其他系统负载
4. 联系DBA进行深入分析

---

## 技术支持

如有问题,请参考:
- [性能问题分析.md](./性能问题分析.md) - 详细的问题分析
- [性能优化报告.md](./性能优化报告.md) - 完整的优化报告

---

**文档版本**: 1.0
**最后更新**: 2025-12-29
