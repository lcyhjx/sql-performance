# usp_UpdateProjectRiskRelationInfo 存储过程性能优化报告

## 执行摘要

**存储过程**: `dbo.usp_UpdateProjectRiskRelationInfo`

**优化日期**: 2025-12-29

**数据库**: Statistics-CT-test

**测试环境**: SQL Server (127.0.0.1:5433)

---

## 一、存储过程功能说明

### 功能描述
每天0点定时刷新合同风险需要使用的相关信息,包括:
- 合同状态
- 第一次打土日期
- 项目累计供应数量
- 项目累计产值
- 项目累计回款
- 项目回款率
- 未办理结算金额
- 项目结算金额

### 涉及的主要数据表

| 表名 | 行数 | 占用空间 | 关键程度 |
|------|------|----------|---------|
| ProductionDailyReportDetails | 34,472,505 | 5.47 GB | ⭐⭐⭐⭐⭐ |
| AccountReceivable | 8,441,365 | 1.08 GB | ⭐⭐⭐⭐⭐ |
| FinanceReports | 593,110 | 31 MB | ⭐⭐⭐⭐ |
| SalesPayment | 296,055 | 30 MB | ⭐⭐⭐ |
| SalesStatements | 252,160 | 66 MB | ⭐⭐⭐ |
| Project | 183,768 | 29 MB | ⭐⭐⭐⭐ |
| ProjectRiskRelationInfo | 56,608 | 6 MB | ⭐⭐⭐⭐⭐ |

---

## 二、原始存储过程实际性能测试

### 测试方法
- 测试轮次: 3次
- 测试时间: 2025-12-29
- 测试环境: 生产环境克隆

### 测试结果

| 轮次 | 执行时间(ms) | 备注 |
|-----|-------------|------|
| 1 | 447 | 首次执行(冷启动) |
| 2 | 9,754 | 正常执行 |
| 3 | 9,188 | 正常执行 |

**平均执行时间**: 6,463 ms (约6.5秒)

### 性能瓶颈识别

通过执行计划分析和IO统计,识别出以下主要性能瓶颈:

1. **ProductionDailyReportDetails 表扫描** - 耗时约 7-8 秒
   - 逻辑读取: 143,973 页
   - 物理读取: 0 页 (已缓存)
   - 扫描次数: 6次

2. **AccountReceivable 表扫描** - 耗时约 1-1.5 秒
   - 逻辑读取: 129,028 页
   - 读取前瞻: 126,476 页
   - 扫描次数: 5次 (执行了2次类似查询)

3. **临时表 JOIN 性能问题**
   - Worktable 逻辑读取: 138,416次
   - 大量的嵌套循环连接

---

## 三、性能问题深度分析

### 问题1: 大量使用 WITH (NOLOCK)

**严重程度**: ⚠️ 高

**问题描述**:
- 在 UPDATE 语句中使用 NOLOCK 是**错误用法**
- 可能导致数据不一致或更新丢失
- 脏读可能导致错误的业务数据

**代码位置**: 第300-323行

```sql
-- ❌ 错误示例
UPDATE prri
FROM ProjectRiskRelationInfo prri WITH (NOLOCK)
```

**修复方案**:
```sql
-- ✅ 正确做法
UPDATE prri
FROM ProjectRiskRelationInfo prri
```

---

### 问题2: 标量子查询重复执行

**严重程度**: 🔴 严重

**问题描述**:
- 相同的参数查询在WHERE子句中被执行2次
- 对于3400万行的表,这会导致百万次重复查询
- f_split函数在大数据集上性能较差

**代码位置**: 第49行, 第126行

```sql
-- ❌ 重复执行
AND details.Type IN (SELECT col FROM dbo.f_split(
    (SELECT ParaValue FROM dbo.Parameters WHERE ParaName='ProjectSalesTypeFilter'),
','))
```

**影响**: 额外增加约1-2秒执行时间

**修复方案**:
```sql
-- ✅ 使用变量缓存
DECLARE @ProjectSalesTypeFilter NVARCHAR(MAX) =
    (SELECT ParaValue FROM dbo.Parameters WHERE ParaName='ProjectSalesTypeFilter');

DECLARE @TypeFilter TABLE (Type NVARCHAR(100));
INSERT INTO @TypeFilter SELECT col FROM dbo.f_split(@ProjectSalesTypeFilter, ',');

-- 使用 JOIN 替代 IN
INNER JOIN @TypeFilter tf ON details.Type = tf.Type
```

---

### 问题3: 临时表缺少索引

**严重程度**: 🔴 严重

**问题描述**:
- 所有临时表在创建后都没有添加索引
- 后续的 JOIN 操作会导致全表扫描
- 特别影响大型 JOIN 操作的性能

**影响的临时表**:
- #TempProj
- #TempProduct
- #TempBLastNR
- #TempCurrentSales
- #TempCurrentReturn
- #TempReturnRate
- #TempStatement
- #TempData

**影响**: 导致Worktable读取138,416次

**修复方案**:
```sql
CREATE CLUSTERED INDEX IX_TempProj_ProjectID ON #TempProj(ProjectID);
CREATE INDEX IX_TempBLastNR_ProjectID ON #TempBLastNR(ProjectID);
-- ... 为所有临时表添加适当的索引
```

---

### 问题4: AccountReceivable 表的重复查询

**严重程度**: 🔴 严重

**问题描述**:
- 对840万行的AccountReceivable表执行了2次类似查询
- 一次查询 PeriodID - 3
- 另一次查询 PeriodID - 2
- 可以合并为一次查询

**代码位置**: 第74-89行, 第102-113行

**影响**: 重复I/O约129,028页,耗时约1秒

**修复方案**:
```sql
-- ✅ 合并查询
SELECT
    ProjectID,
    SUM(CASE WHEN PeriodID = @PeriodID - 3 THEN ... END) AS P3_Value,
    SUM(CASE WHEN PeriodID = @PeriodID - 2 THEN ... END) AS P2_Value
FROM AccountReceivable
WHERE PeriodID IN (@PeriodID - 3, @PeriodID - 2)
GROUP BY ProjectID
```

---

### 问题5: 日期计算重复执行

**严重程度**: ⚠️ 中

**问题描述**:
- 复杂的日期计算在每个查询中重复执行
- GETDATE() 的多次调用可能导致不一致
- 影响查询优化器的性能估算

**代码位置**: 第125行, 第157行, 第168行

```sql
-- ❌ 重复计算
DATEADD(MM, DATEDIFF(MM, 0, DATEADD(MM, -1, GETDATE())), 0)
```

**修复方案**:
```sql
-- ✅ 预先计算
DECLARE @CurrentDate DATE = CAST(GETDATE() AS DATE);
DECLARE @StartDate_1MonthAgo DATE =
    DATEADD(MM, DATEDIFF(MM, 0, DATEADD(MM, -1, @CurrentDate)), 0);
```

---

### 问题6: UPDATE + INSERT 可以优化为 MERGE

**严重程度**: 🟡 低

**问题描述**:
- 使用 UPDATE + INSERT 两个操作
- NOT EXISTS 子查询对每条记录执行
- 可以使用 MERGE 语句一次完成

**代码位置**: 第300-378行

**修复方案**:
```sql
-- ✅ 使用 MERGE
MERGE INTO dbo.ProjectRiskRelationInfo AS target
USING #TempData AS source ON target.ProjectID = source.ProjectID
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT (...) VALUES (...);
```

---

### 问题7: 缺少事务控制和错误处理

**严重程度**: 🔴 严重

**问题描述**:
- 没有显式事务控制
- 缺少错误处理机制
- 如果中途失败,可能导致部分数据更新

**修复方案**:
```sql
BEGIN TRY
    BEGIN TRANSACTION;

    -- 所有操作

    COMMIT TRANSACTION;
END TRY
BEGIN CATCH
    IF @@TRANCOUNT > 0
        ROLLBACK TRANSACTION;
    THROW;
END CATCH;
```

---

## 四、优化方案

### 优化策略总览

| 优化项 | 优先级 | 预期提升 | 实施难度 |
|--------|--------|---------|---------|
| 临时表添加索引 | 🔴 高 | 50-70% | 简单 |
| 子查询变量化 | 🔴 高 | 15-25% | 简单 |
| 合并AccountReceivable查询 | ⚠️ 中 | 20-30% | 中等 |
| 日期计算优化 | 🟡 低 | 5-10% | 简单 |
| 使用MERGE语句 | 🟡 低 | 10-20% | 简单 |
| 添加事务控制 | 🔴 高 | 0% (稳定性) | 简单 |
| 移除UPDATE中的NOLOCK | 🔴 高 | 0% (正确性) | 简单 |

### 主要优化内容

#### 1. 变量和常量预计算

```sql
-- 预先计算所有常量
DECLARE @PeriodID BIGINT = (...);
DECLARE @ProjectSalesTypeFilter NVARCHAR(MAX) = (...);
DECLARE @CurrentDate DATE = CAST(GETDATE() AS DATE);
DECLARE @StartDate_3MonthsAgo DATE = ...;
DECLARE @StartDate_1MonthAgo DATE = ...;

-- 创建类型过滤表
DECLARE @TypeFilter TABLE (Type NVARCHAR(100));
INSERT INTO @TypeFilter SELECT col FROM dbo.f_split(@ProjectSalesTypeFilter, ',');
```

#### 2. 临时表索引策略

```sql
-- 为每个临时表创建聚集索引
CREATE CLUSTERED INDEX IX_TempProj_ProjectID ON #TempProj(ProjectID);
CREATE INDEX IX_TempProj_SalesContractID ON #TempProj(SalesContractID);

CREATE CLUSTERED INDEX IX_TempProduct_ProjectID ON #TempProduct(ProjectID);
-- ... 其他临时表
```

#### 3. 合并重复查询

```sql
-- 将两次AccountReceivable查询合并为一次
SELECT
    ProjectID,
    MAX(ProductCategory) AS ProductCategory,
    SUM(CASE WHEN PeriodID = @PeriodID - 3 THEN ... END) AS P3_Data,
    SUM(CASE WHEN PeriodID = @PeriodID - 2 THEN ... END) AS P2_Data
FROM AccountReceivable
WHERE PeriodID IN (@PeriodID - 3, @PeriodID - 2)
GROUP BY ProjectID
```

#### 4. 使用MERGE语句

```sql
MERGE INTO dbo.ProjectRiskRelationInfo AS target
USING #TempData AS source ON target.ProjectID = source.ProjectID
WHEN MATCHED THEN UPDATE SET FGC_LastModifyDate = GETDATE(), ...
WHEN NOT MATCHED THEN INSERT (...) VALUES (...);
```

#### 5. 添加错误处理和日志

```sql
BEGIN TRY
    BEGIN TRANSACTION;

    PRINT CONCAT('Step1: ... - 耗时: ', DATEDIFF(ms, @StepTime, SYSDATETIME()), 'ms');

    COMMIT TRANSACTION;
    PRINT CONCAT('总执行时间: ', DATEDIFF(ms, @StartTime, SYSDATETIME()), 'ms');
END TRY
BEGIN CATCH
    IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
    PRINT CONCAT('错误: ', ERROR_MESSAGE());
    THROW;
END CATCH;
```

---

## 五、建议的索引

### 需要创建的索引

```sql
-- 1. ProductionDailyReportDetails表
CREATE NONCLUSTERED INDEX IX_ProductionDetails_Type_ProjectID_Optimized
ON ProductionDailyReportDetails(Type, ProjectID, DailyReportID)
INCLUDE (ReceiptDate, FinalQty_M3, FinalQty_T, SalesTotalAmt1, Unit);

-- 2. AccountReceivable表
CREATE NONCLUSTERED INDEX IX_AccountReceivable_PeriodID_ProjectID_Optimized
ON AccountReceivable(PeriodID, ProjectID, isDeleted, FinanceRptID)
INCLUDE (CurrentACCUSalesIncomeTotalAmt, CurrentACCUFinalQty_T, ...);

-- 3. SalesPayment表
CREATE NONCLUSTERED INDEX IX_SalesPayment_PaymentDate_ProjectID_Optimized
ON SalesPayment(PaymentDate, ProjectID, isDeleted)
INCLUDE (Amount);

-- 4. SalesServiceIncome表
CREATE NONCLUSTERED INDEX IX_SalesServiceIncome_PaymentDate_Type_Optimized
ON SalesServiceIncome(PaymentDate, ServiceType, ProjectID, isDeleted)
INCLUDE (RefundAmt);

-- 5. SalesStatements表
CREATE NONCLUSTERED INDEX IX_SalesStatements_ProjectID_Calculated_Optimized
ON SalesStatements(ProjectID, isDeleted, IsVoid, ifCalculate)
INCLUDE (SalesAmt, SignDate);

-- 6. ProjectRiskRelationInfo表
CREATE UNIQUE NONCLUSTERED INDEX IX_ProjectRiskRelationInfo_ProjectID_Unique
ON ProjectRiskRelationInfo(ProjectID);
```

### 索引影响分析

**磁盘空间需求**: 预计增加约 2-3 GB

**维护成本**:
- INSERT/UPDATE/DELETE 操作会略微变慢(约5-10%)
- 但查��性能提升50-80%,整体收益远大于成本

**建议创建时间**: 业务低峰期(凌晨2-4点)

---

## 六、性能预期

### 优化前后对比预测

| 指标 | 优化前 | 优化后(预期) | 提升幅度 |
|------|--------|-------------|---------|
| 平均执行时间 | 6.5秒 | 1.5-2.5秒 | 60-75% ⬇ |
| IO逻辑读取 | ~400,000页 | ~150,000页 | 62% ⬇ |
| CPU时间 | ~12秒 | ~3-5秒 | 60-75% ⬇ |
| 临时表JOIN性能 | 慢 | 快10-100倍 | ⬆⬆⬆ |
| 数据一致性 | 有风险 | 有保障 | ✅ |
| 错误恢复能力 | 无 | 完整 | ✅ |

### 长期收益

假设此存储过程每天执行1次:

- **每天节省时间**: 4-5秒
- **每月节省时间**: 2-2.5分钟
- **每年节省时间**: 24-30分钟

**其他收益**:
- 减少数据库服务器负载
- 降低锁竞争风险
- 提高系统稳定性
- 便于问题排查和监控

---

## 七、实施计划

### 第一阶段: 准备工作(1-2天)

1. ✅ 备份当前存储过程
2. ✅ 创建优化后的存储过程 (`_Optimized` 版本)
3. ✅ 编写性能测试脚本
4. ⏳ 在测试环境进行充分测试

### 第二阶段: 索引创建(1-2小时)

1. 选择业务低峰期(凌晨2-4点)
2. 使用 `ONLINE = ON` 选项创建索引
3. 监控索引创���进度和系统负载
4. 完成后更新统计信息

### 第三阶段: 灰度发布(1周)

1. 在生产环境创建优化版存储过程
2. 手动执行几次,对比结果
3. 验证数据一致性
4. 监控性能指标

### 第四阶段: 正式替换(1天)

1. 选择业务低峰期
2. 备份当前生产数据
3. 替换存储过程定义
4. 监控首次定时执行
5. 准备回滚方案

---

## 八、风险评估与应对

### 潜在风险

| 风险 | 概率 | 影响 | 应对措施 |
|------|------|------|---------|
| 优化后结果不一致 | 低 | 高 | 充分测试,数据对比验证 |
| 索引创建锁表 | 低 | 中 | 使用ONLINE选项,选择低峰期 |
| 性能反而下降 | 很低 | 中 | 保留原存储过程,快速回滚 |
| 磁盘空间不足 | 低 | 中 | 提前评估空间需求 |

### 回滚方案

1. 保留原始存储过程定义
2. 一键切换脚本准备就绪
3. 删除优化索引的脚本准备就绪
4. 数据库备份在替换前完成

---

## 九、监控指标

### 关键监控指标

1. **执行时间**
   - 目标: < 3秒
   - 告警阈值: > 5秒

2. **逻辑读取量**
   - 目标: < 200,000页
   - 告警阈值: > 300,000页

3. **CPU时间**
   - 目标: < 5秒
   - 告��阈值: > 8秒

4. **错误率**
   - 目标: 0%
   - 告警阈值: > 0%

### 监控查询

```sql
-- 查看存储过程执行统计
SELECT
    execution_count,
    total_elapsed_time / 1000 / execution_count AS avg_elapsed_ms,
    total_worker_time / 1000 / execution_count AS avg_cpu_ms,
    total_logical_reads / execution_count AS avg_logical_reads,
    last_execution_time
FROM sys.dm_exec_procedure_stats
WHERE object_name(object_id) = 'usp_UpdateProjectRiskRelationInfo';
```

---

## 十、附录

### 文件清单

1. **原始存储过程定义**
   - `usp_UpdateProjectRiskRelationInfo_definition.sql`

2. **优化后的存储过程**
   - `usp_UpdateProjectRiskRelationInfo_Optimized.sql`

3. **索引创建脚本**
   - `Create_Indexes.sql`

4. **性能测试脚本**
   - `Performance_Test.sql`
   - `test_usp_UpdateProjectRiskRelationInfo_performance.py`

5. **性能分析报告**
   - `性能问题分析.md`
   - 本文档

### 执行步骤

```sql
-- 1. 创建索引
USE [Statistics-CT-test];
GO
-- 执行 Create_Indexes.sql

-- 2. 创建优化后的存储过程
-- 执行 usp_UpdateProjectRiskRelationInfo_Optimized.sql

-- 3. 运行性能测试
-- 执行 Performance_Test.sql
-- 或运行 Python测试脚本

-- 4. 对���验证数据一致性
SELECT * FROM ProjectRiskRelationInfo
ORDER BY ProjectID;

-- 5. 替换生产存储过程(谨慎操作!)
DROP PROCEDURE dbo.usp_UpdateProjectRiskRelationInfo;
GO
EXEC sp_rename
    'dbo.usp_UpdateProjectRiskRelationInfo_Optimized',
    'usp_UpdateProjectRiskRelationInfo';
```

---

## 十一、结论与建议

### 结论

1. 原始存储过程存在多个严重性能问题
2. 主要瓶颈在于大表扫描和缺少临时表索引
3. 优化方案预期可提升 **60-75%** 的性能
4. 同时显著提升数据一致性和系统稳定性

### 建议

1. **立即实施**:
   - 移除 UPDATE 中的 NOLOCK(数据正确性问题)
   - 添加事务和错误处理(数据一致性问题)

2. **短期实施**(1-2周):
   - 创建建议的索引
   - 部署优化后的存储过程

3. **长期优化**:
   - 定期监控执行性能
   - 根据数据增长调整索引策略
   - 考虑是否需要数据归档

4. **其他建议**:
   - 建立存储过程性能基线
   - 设置自动性能监控告警
   - 定期review执行计划

---

**报告编制**: Claude Sonnet 4.5
**报告日期**: 2025-12-29
**版本**: 1.0
