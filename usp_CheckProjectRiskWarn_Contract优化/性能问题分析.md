# usp_CheckProjectRiskWarn_Contract 存储过程性能优化报告

## 一、执行摘要

**存储过程名称**: `dbo.usp_CheckProjectRiskWarn_Contract`

**功能描述**: 每天巡检在建项目未签合同风险的数据

**当前性能**: 平均执行时间 **4.9秒** (首次6.1秒,后续4.2-4.3秒)

**优化目标**: 将执行时间降至 **1.5-2.5秒** (提升60-70%)

---

## 二、原始SQL性能测试结果

### 测试环境
- 数据库: Statistics-CT-test
- 测试时间: 2025-12-29
- 测试轮次: 3次

### 实际执行性能

| 轮次 | 执行时间(ms) | 备注 |
|-----|-------------|------|
| 1 | 6,112 | 首次执行(冷启动) |
| 2 | 4,237 | 正常执行 |
| 3 | 4,218 | 正常执行 |

**平均执行时间**: 4,855 ms (约4.9秒)

---

## 三、主要性能问题分析

### 问题1: 标量子查询重复执行 ⭐⭐⭐⭐⭐

**严重程度**: 🔴 严重

**位置**: 第28行

```sql
-- ❌ 问题代码
AND details.Type IN (SELECT col FROM dbo.f_split(
    (SELECT ParaValue FROM dbo.Parameters WHERE ParaName='ProjectSalesTypeFilter'),
','))
```

**问题描述**:
- 对3400万行的ProductionDailyReportDetails表,每次扫描都要执行参数查询
- f_split函数性能较差
- 可能导致数百万次重复查询

**修复方案**:
```sql
-- ✅ 优化代码
DECLARE @ProjectSalesTypeFilter NVARCHAR(MAX) =
    (SELECT ParaValue FROM dbo.Parameters WHERE ParaName='ProjectSalesTypeFilter');

DECLARE @TypeFilter TABLE (Type NVARCHAR(100));
INSERT INTO @TypeFilter SELECT col FROM dbo.f_split(@ProjectSalesTypeFilter, ',');

-- 使用 JOIN 替代 IN
INNER JOIN @TypeFilter tf ON details.Type = tf.Type
```

**预期提升**: 减少30-40%执行时间

---

### 问题2: 临时表缺少索引 ⭐⭐⭐⭐⭐

**严重程度**: 🔴 严重

**影响的临时表**:
- #TempProduct
- #TempProjdata
- #Temp1
- #Temp2
- #Temp1Warn
- #Temp2Warn

**问题描述**:
- 所有临时表创建后都没有索引
- 后续的JOIN和EXISTS查询导致全表扫描

**修复方案**:
```sql
CREATE CLUSTERED INDEX IX_TempProduct_ProjectID ON #TempProduct(ProjectID);
CREATE CLUSTERED INDEX IX_TempProjdata_ID ON #TempProjdata(ID);
CREATE INDEX IX_TempProjdata_CorpType ON #TempProjdata(CorpType);
-- ... 为其他临时表添加索引
```

**预期提升**: 减少20-30%执行时间

---

### 问题3: UPDATE语句使用NOLOCK ⭐⭐⭐⭐⭐

**严重程度**: 🔴 严重

**位置**: 第290行, 301行, 313行, 330行, 348行, 365行

```sql
-- ❌ 错误用法
UPDATE pr
FROM ProjectRisk pr WITH (NOLOCK)
```

**问题描述**:
- UPDATE语句中使用NOLOCK是错误的
- 可能导致数据损坏或更新丢失
- NOLOCK只应用于SELECT

**修复方案**:
```sql
-- ✅ 正确做法
UPDATE pr
FROM ProjectRisk pr
```

**影响**: 数据正确性问题(必须修复)

---

### 问题4: UNION重复查询 ⭐⭐⭐⭐

**严重程度**: ⚠️ 中

**位置**: 第53-74行

**问题描述**:
- 对Project和SalesContracts表进行了两次几乎相同的查询
- 唯一区别是AgentID的判断条件
- 可以合并为一次查询

**修复方案**:
```sql
-- ✅ 合并查询
SELECT p.*, c.CorpType
INTO #TempProjdata
FROM dbo.Project p WITH (NOLOCK)
    INNER JOIN dbo.SalesContracts c WITH (NOLOCK)
        ON p.SalesContractID = c.ID
WHERE p.Type = 1
      AND p.AccountingPaymentType <> '现金'
      AND ISNULL(p.isPartnerProjFinished, 0) = 0
      AND (
          (p.AgentID IS NULL AND LTRIM(RTRIM(ISNULL(c.SignStatus, ''))) NOT IN ('已签', '付清', '此合同号作废'))
          OR
          (p.AgentID IS NOT NULL AND LTRIM(RTRIM(ISNULL(p.AgentAgreementSignStatus, ''))) NOT IN ('已签'))
      );
```

**预期提升**: 减少10-15%执行时间

---

### 问题5: NOT EXISTS子查询效率低 ⭐⭐⭐

**严重程度**: 🟡 低

**位置**: 第250-258行, 276-284行

**问题描述**:
- NOT EXISTS会对每条记录执行子查询
- 可以使用LEFT JOIN IS NULL替代

**修复方案**:
```sql
-- ✅ 使用LEFT JOIN
INSERT INTO dbo.ProjectRisk (...)
SELECT ...
FROM #Temp1Warn t
    LEFT JOIN dbo.ProjectRisk pr
        ON pr.ProjectID = t.ProjectID
        AND pr.IsDeleted = 0
        AND pr.RiskType = 1
        AND pr.WarnType = 1
WHERE pr.ProjectID IS NULL;
```

**预期提升**: 减少5-10%执行时间

---

### 问题6: 缺少事务控制 ⭐⭐⭐⭐

**严重程度**: 🔴 严重

**问题描述**:
- UPDATE和INSERT操作没有显式事务
- 如果中途失败,可能导致部分数据更新
- 缺少错误处理机制

**修复方案**:
```sql
BEGIN TRY
    BEGIN TRANSACTION;

    -- 所有操作

    COMMIT TRANSACTION;
END TRY
BEGIN CATCH
    IF @@TRANCOUNT > 0
        ROLLBACK TRANSACTION;

    DECLARE @ErrorMessage NVARCHAR(4000) = ERROR_MESSAGE();
    RAISERROR(@ErrorMessage, 16, 1);
END CATCH;
```

**影响**: 数据一致性保障

---

### 问题7: @ProjectID判断错误 ⭐⭐⭐

**严重程度**: ⚠️ 中

**位置**: 第42行

```sql
-- ❌ 错误判断
IF (@ProjectID != NULL)
```

**问题描述**:
- NULL值不能用!=或=比较
- 这个条件永远为FALSE
- 应该使用IS NOT NULL

**修复方案**:
```sql
-- ✅ 正确判断
IF (@ProjectID IS NOT NULL)
```

---

## 四、优化方案总览

| 优化项 | 优先级 | 预期提升 | 实施难度 |
|--------|--------|---------|---------|
| 子查询变量化 | 🔴 高 | 30-40% | 简单 |
| 临时表索引 | 🔴 高 | 20-30% | 简单 |
| 合并UNION查询 | ⚠️ 中 | 10-15% | 简单 |
| 优化NOT EXISTS | 🟡 低 | 5-10% | 简单 |
| 移除UPDATE中NOLOCK | 🔴 高 | 0% (正确性) | 简单 |
| 添加事务控制 | 🔴 高 | 0% (稳定性) | 简单 |
| 修复NULL判断 | ⚠️ 中 | 0% (正确性) | 简单 |

**总体预期**: 执行时间减少 **60-70%**

---

## 五、建议的索引

### 需要验证/添加的索引

```sql
-- 1. ProductionDailyReportDetails表
-- (可能已有类似索引,需验证)
CREATE INDEX IX_ProdDetails_Type_ProjectID
ON ProductionDailyReportDetails(Type, ProjectID)
INCLUDE (ReceiptDate, Unit, FinalQty_T, FinalQty_M3, Unpaid, DailyReportID);

-- 2. Project表
CREATE INDEX IX_Project_Type_Payment_Agent
ON Project(Type, AccountingPaymentType, AgentID)
INCLUDE (SalesContractID, isPartnerProjFinished, AgentAgreementSignStatus, isDeleted);

-- 3. ProjectRisk表
CREATE INDEX IX_ProjectRisk_Type_Warn_Del
ON ProjectRisk(RiskType, WarnType, IsDeleted, IsStop)
INCLUDE (ProjectID, NewStopDate, NewStopQty);

-- 4. ProjectRiskWarn表
CREATE INDEX IX_ProjectRiskWarn_Type_Del
ON ProjectRiskWarn(RiskType, IsDeleted);
```

---

## 六、性能预期对比

| 指标 | 优化前 | 优化后(预期) | 提升幅度 |
|------|--------|-------------|---------|
| 平均执行时间 | 4.9秒 | 1.5-2.0秒 | 60-70% ⬇ |
| 首次执行时间 | 6.1秒 | 2.0-2.5秒 | 60-70% ⬇ |
| 数据正确性 | 有风险 | 有保障 | ✅ |
| 错误恢复能力 | 无 | 完整 | ✅ |

---

## 七、主要优化点说明

### 1. 预计算常量和变量

```sql
-- 在存储过程开始处添加
DECLARE @ProjectSalesTypeFilter NVARCHAR(MAX) =
    (SELECT ParaValue FROM dbo.Parameters WHERE ParaName='ProjectSalesTypeFilter');

DECLARE @TypeFilter TABLE (Type NVARCHAR(100));
INSERT INTO @TypeFilter
SELECT col FROM dbo.f_split(@ProjectSalesTypeFilter, ',');

DECLARE @CurrentDate DATE = CAST(GETDATE() AS DATE);
```

### 2. 为临时表添加索引

```sql
-- 每个临时表创建后立即添加索引
SELECT ... INTO #TempProduct FROM ...;
CREATE CLUSTERED INDEX IX_TempProduct_ProjectID ON #TempProduct(ProjectID);
```

### 3. 合并重复查询

```sql
-- 将UNION的两个查询合并为��个
SELECT p.*, c.CorpType
INTO #TempProjdata
FROM dbo.Project p WITH (NOLOCK)
    INNER JOIN dbo.SalesContracts c WITH (NOLOCK)
        ON p.SalesContractID = c.ID
WHERE p.Type = 1
      AND p.AccountingPaymentType <> '现金'
      AND ISNULL(p.isPartnerProjFinished, 0) = 0
      AND (
          (p.AgentID IS NULL AND LTRIM(RTRIM(ISNULL(c.SignStatus, ''))) NOT IN ('已签', '付清', '此合同号作废'))
          OR
          (p.AgentID IS NOT NULL AND LTRIM(RTRIM(ISNULL(p.AgentAgreementSignStatus, ''))) NOT IN ('已签'))
      );
```

### 4. 添加完整的事务控制

```sql
BEGIN TRY
    BEGIN TRANSACTION;

    -- Step1-5 的所有操作

    COMMIT TRANSACTION;
END TRY
BEGIN CATCH
    IF @@TRANCOUNT > 0
        ROLLBACK TRANSACTION;

    THROW;
END CATCH;
```

---

## 八、实施建议

### 立即修复(数据正确性问题)
1. ✅ 移除所有UPDATE语句中的NOLOCK
2. ✅ 修复@ProjectID的NULL判断
3. ✅ 添加事务控制和错误处理

### 短期优化(1-2周)
4. ✅ 添加变量缓存子查询
5. ✅ 为所有临时表添加索引
6. ✅ 合并UNION查询
7. ✅ 优化NOT EXISTS为LEFT JOIN

### 长期优化
8. ✅ 创建建议的物理表索引
9. ✅ 定期监控执行性能
10. ✅ 考虑数据归档策略

---

**报告编制**: Claude Sonnet 4.5
**报告日期**: 2025-12-29
**版本**: 1.0
